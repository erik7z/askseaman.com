type Question implements CanBeCommented & CanBeLiked & CanBeVoted & CanBeSubscribed {
	nodeId: ID! @id
	title: String!
	text: String!
	createdAt: DateTime
	updatedAt: DateTime
	viewsCount: Int
	canVote: Boolean #TODO:logic to decide if user can vote (depended on some rating)
	upVotesCount: Int
		@cypher(
			statement: "RETURN size((this)<-[:VOTED_UP]-(:User)) as upVotesCount"
		)
	downVotesCount: Int
		@cypher(
			statement: "RETURN size((this)<-[:VOTED_DOWN]-(:User)) as downVotesCount"
		)
	answersCount: Int
		@cypher(
			statement: "RETURN size((this)-[:HAS_ANSWER]->(:Answer)) as answersCount"
		)
	commentsCount: Int
		@cypher(
			statement: "RETURN size((this)-[:HAS_COMMENT]->(:Comment)) as commentsCount"
		)
	likesCount: Int
		@cypher(statement: "RETURN size((this)<-[:LIKED]-(:User)) as likesCount")
	subscribersCount: Int
		@cypher(
			statement: "RETURN size((this)<-[:SUBSCRIBED]-(:User)) as subscribersCount"
		)

	author: User! @relation(name: "ASKED", direction: IN)
	answers: [Answer] @relation(name: "HAS_ANSWER", direction: OUT)
	comments: [Comment] @relation(name: "HAS_COMMENT", direction: OUT)
	tags: [Tag] @relation(name: "TAGGED", direction: IN)
	likes: [User] @relation(name: "LIKED", direction: IN)
	subscribers: [User] @relation(name: "SUBSCRIBED", direction: IN)
}

type Mutation {
	AskQuestion(data: AskQuestionInput!): Question!
		@isAuthenticated
		@cypher(
			statement: """
			MATCH (u:User {nodeId: $cypherParams.currentUserId})
			CREATE (q:Question:CanBeCommented:CanBeVoted:CanBeSubscribed)<-[:ASKED]-(u)
			SET q += {title: $data.title, text: $data.text, nodeId: apoc.create.uuid(), createdAt: DateTime()}
			WITH q
			CALL {
				WITH q
				MATCH (t:Tag) where t.name IN $data.tags
				MERGE (t)-[r:TAGGED]->(q)
				RETURN count(t) as added_tags
			}
			RETURN q
			"""
		)

	EditQuestion(data: EditQuestionInput!): Question!
		@isAuthenticated
		@cypher(
			statement: """
			MATCH (q:Question {nodeId:$data.nodeId})<-[:ASKED]-(u:User {nodeId: $cypherParams.currentUserId})
			SET q += {title: $data.title, text: $data.text, updatedAt: DateTime()}
			WITH q
			CALL {
				WITH q
				MATCH (t:Tag)-[r:TAGGED]->(q)
				DELETE r
				RETURN count(t) as deleted_tags
			}
			WITH q
			CALL {
				WITH q
				MATCH (t:Tag) where t.name IN $data.tags
				MERGE (t)-[r:TAGGED]->(q)
				RETURN count(t) as added_tags
			}
			RETURN q
			"""
		)

	#TODO: Delete related comments
	DeleteQuestion(data: nodeIdInput!): DeleteQuestionResponse!
		@isAuthenticated
		@cypher(
			statement: """
			MATCH (q:Question {nodeId:$data.nodeId})<-[:ASKED]-(u:User {nodeId: $cypherParams.currentUserId})
			WITH q, properties(q) AS m
			DETACH DELETE q
			RETURN m
			"""
		)
}
